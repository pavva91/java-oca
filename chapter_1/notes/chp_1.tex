\documentclass{article}

\author{Bob Smiths}
\title{Chapter 1 - Java Building Blocks}

\begin{document}

\maketitle

\section{Java Class Structure}
Java basic structure is composed of classes that are instatiated as objects.

\textbf{CLASSES} := Classes are the basic building blocks.

\textbf{OBJECT} := An object is a \underline{runtime instace} of a class in memory.

\subsection{Field and Methods}
Java classes have two primary elements: \textit{methods} and \textit{fields}

\textbf{PUBLIC} := Is used to signify that this method may be called from other classes.

\textbf{VOID} := void means that no value at all is returned.

\textbf{PARAMETER} := The information required as input in the method.

\textbf{METHOD SIGNATURE} := The full declarationn of a method.

\subsection{Classes vs. Files}
You can even put two classes in the same file. At most one of the classes in the file is allowed to be public.
The public class needs to match the filename.

\subsection{Writing a \textit{main()} Method}
\textbf{COMPILE JAVA CODE} := javac on .java source file.

\textbf{RUN COMPILED JAVA} := java on .class bytecode file (no file extension needed)
:w

\textbf{ACCESS MODIFIER} := Declares the method's level of exposure.

\textbf{\textit{static} KEYWORD} := Binds a method to tis class so it can be called by just the class name.

\textbf{ARRAY} := An array is a fixed-size list of items that are all of the same type. An array is represented by ``[]'' brackets.

\textbf{VARARGS} := The characters ``...'' are called varargs (variable argument lists)

\subsection{Understanding Package Declarations and Imports}
\textbf{PACKAGES} := Packages are logical groupings for classes.

\textbf{IMPORT STATEMENT} := The import statement tells the compiler which package to look in to find a class.

\textbf{PACKAGE NAMING} := The rules for package names are the same as for variable names.

\textbf{COMPILERS FIGURES OUT WHAT IS ACTUALLY NEEDED} := One might think that including so many classes slows down the program, but it doesn't. The compiler figures out what's actually needed.

\textbf{NAMING CONFLICTS} := One of the reasons for using packages is so that class names don't have to be unique across all of java.

\textbf{DEFAULT PACKAGE} := This is a special unnamed package that you should use only for throwaway code. Is the default package because there's no package name.

\subsection{Constructors}
The name of the constructor matches the name of the class and there's no return type.

The purpose of the constructor is to initialize fields.

For most classes, you don't have to code a constructor - the compiler will supply a ``do nothing'' default constructor for you.

\subsection{Instance Initializer Blocks}
\textbf{CODE BLOCK} := The code between the braces is called a \textit{code block}

\textbf{INSTANCE INITIALIZER} := Code blocks that appear outside a method.

\subsection{Order of Initialization}
The order of initialization is:
\begin{itemize}
	\item Fields and instance initializer blocks are run in the order in which they appear in the file.
	\item The constructor runs after all fields and instance initializer blocks have run.
\end{itemize}
NOTE: Order matters for the fields and blocks of code.

\subsection{Distinguishing Between Object References and Primitives}
Java applications contains two types of data:
\begin{enumerate}
	\item Primitive types
	\item Reference tyeps
\end{enumerate}

\subsection{Primitive Types}
Java has eight built-in data types, called \textit{primitive types}. These eight data types represent the building blocks for Java objects, because all Java objects are just a complex collection of these primitive data types:
\begin{itemize}
	\item boolean
	\item byte
	\item short
	\item int
	\item long
	\item float
	\item double
	\item char
\end{itemize}

\textbf{LITERAL} := When a number is present in hte code, it is called literal

\subsubsection{Java Bases}
Another way to specify numbers is to change the ``base''. Java allows you to specify digits in several formats:
\begin{itemize}
	\item octal (digits 0-7), which uses the number 0 as a prefix - e.g.: 017
	\item hexadecimal (digits 0-9 and letters A-F), which uses the number 0 followed by x of X as a prefix - e.g.: 0xF5
	\item binary (digits 0-1), which uses the number 0 followed by b or B as a prefix - e.g.: 0b1011
\end{itemize}

\subsubsection{Underscore in Numbers}
You can have underscores in numbers to make them easier to read.

\textbf{RULE} := You can add underscores anywhere except:
\begin{itemize}
	\item At the beginning of a literal
	\item At the end of a literal
	\item Right before a decimal point
	\item Right after a decimal point
\end{itemize}

\subsection{Reference Types}

A reference type refers to an object (an instace of a class). Unlike primitive types that hold their values in the memory where the variable is allocated, references do not hold the value of the object they refer to. Instead, a reference ``points'' to an object by sotring the memory address where the object is located.

\textbf{POINTER} := A reference ``points'' to an object by storing the memory address where the object is located.

\textbf{ASSIGN REFERENCE} := There are 2 ways to assign a value to a reference:
\begin{itemize}
	\item A reference can be assigned to another object of the same type.
	\item A reference can be assigned to a new object using the new keyword.
\end{itemize}

\subsubsection{Key Differences}
\begin{enumerate}
	\item\textbf{NULL ASSIGNMENT} : Reference Types can be assigned null, which means they do not currently refer to an object. Primitive types will give you a compiler error if you attempt to assign them null.

	\item\textbf{CALL METHODS} : Reference types can be used to call methods when they do not point to null. Primitives do not have methods declared on them.
	\item All the primitive types have lowercase type names. All classes that come with Java begin with uppercase.
\end{enumerate}

\subsection{Declaring and Initializing Variables}
\textbf{VARIABLE} := A variable is a name for a piece of memory that stores data.

\subsection{Identifiers Rules}
There are only three rules to remember for legal identifiers:
\begin{enumerate}
	\item The name must begin with a letter or the symbol \$ or \_.
	\item Subsequent characters may also be numbers.
	\item You cannot use the same name as a Java \textit{reserved word}.
\end{enumerate}

\subsection{Reserved Words}
A reserved word is a keyword that Java has reserved so that you are not allowed to use it.
NOTE: Remember that Java is case sensitive, so you can use versions of the keywords that only differ in case. Please don't, though.

Here is the list with all the 53 reserved words:
\begin{itemize}
	\item abstract
	\item assert
	\item boolean
	\item break
	\item byte
	\item case
	\item catch
	\item char
	\item class
	\item const*
	\item continue
	\item default
	\item do
	\item double
	\item else
	\item enum
	\item extends
	\item false
	\item final
	\item finally
	\item float
	\item for
	\item goto*
	\item if
	\item implements
	\item import
	\item instanceof
	\item int
	\item interface
	\item long
	\item native
	\item new
	\item null
	\item package
	\item private
	\item protected
	\item public
	\item return
	\item short
	\item static
	\item strictfp
	\item super
	\item switch
	\item synchronized
	\item this
	\item throw
	\item throws
	\item transient
	\item true
	\item try
	\item void
	\item volatile
	\item while
\end{itemize}

\textbf{JAVA CONVENTION: CamelCase} : Java has conventions so that code is readable and consistent. This consistency includes CamelCase. In CamelCase, each word begins with an uppercase letter. This makes multiple-word variable names easier to read (e.g. ThisIsCamelCaseNaming).

\subsection{variables}
Types of variables:
\begin{itemize}
	\item local
	\item instance
	\item class
\end{itemize}


\textbf{Local Variable} : A local variable is a variable defined whithin a method. Local variables must be initialized before use. They do not have a default value and contain garbage data until initialized. The compiler will not let you read an uninitialized value.

\textbf{Instance Variable (field)} : Variables that are not local variables are known as instance variables or class variables. Instance variables are also called fields.

\textbf{Class Variable} : Class variables are shared cross multiple objects. You can tell a variable is a class variable because it has the keyword static before it.

Instance and class variable do not require you to initialize them. As soon as you declare these variables, they are given a default value.


\begin{tabular}{|c|c|}
	\cline{1-2}
	    Variable Type & Default Initialization value \\
	\cline{1-2}
	    boolean & false \\
	    byte, short, int, long & 0 \\
	    float, double & 0.0 \\
	    char & '\u0000' (NUL) \\
	    All object references (everything else) & null \\

	\cline{1-2}
\end{tabular}

Note: A method parameter is a local variable.
Local variables can never have a scope larger than the method they are defined in. However, they can have a smaller scope.

\textbf{Variable Scopes} :
\begin{itemize}
	\item Local variables - in scope from declarationn to end of block.
	\item Instance variables - in scope from declaration until object garbage collected.
	\item Class variables - in scope from declaration until program ends.
\end{itemize}


\section{Ordering Elements in a Class}
\begin{tabular}{|c|c|c|c|}
	\cline{1-4}
	Element & Example & Required? & Where does it go? \\
	\cline{1-4}
	Package Declaration & package abc; & No & First line in the file \\
	Import statements & import java.util.*; & No & Immediately after the package \\
	Class declaration & public class C & Yes & Immediately after the import \\
	Field declarations & int value; & No & Anywhere inside a class \\
	Method declarations & void method() & No & Anywhere inside a class \\
	\cline{1-4}
\end{tabular}

PIC: Package, Import, Class

Multiple classes can be dfined in the same file, but only one of them is allowed to be public. The public class must match the name of the file.

\section{Destroying Objects}
Java automatically takes care of that for you. Java provides a garbage collector to automatically look for objeects that arent't needed anymore.
All Java objects are stored in your program memory's heap. The ehap, which is also referred to as the free store, represents a large pool of unused memory allocated to your Java application.
\subsection{Garbage Collection}
Garbage collection refers to the process of automatically freeing memory on the heap by deleting objects that are no longer reachable in your program.
You need to know that System.gc() is not guaranteed to run, and you should be able to recognize when objects become eligible for garbage collection.
When calling System.gc() we are merely suggesting Java to kick off a garbage collection run. Java is free to ignore the request.
An object will remain in the heap until it is no longer reachable. An object is no longer reachable when one of two situations occurs:
\begin{itemize}
	\item The object no longer has any references pointing to it.
	\item All references to the object have gone out of scope.
\end{itemize}

\subsection{finalize()}
Java allows objects to implement a method called finalize() that might get called. This method gets called if the garbage collector tries to collect the object. If the garbage collector doesn't run, the method doesn't get called. If the garbage collector fails to collect the object and tries to run it again later, the method doesn't get called a second time.
Keep in mind that it might not get called and that it definitely won't be called twice.
finalize() call could run zero or one time. finalize() is only run when the object is eligible for garbage collection.

\section{Benefits of Java}
Java has some key benefits:
\begin{itemize}
	\item \textbf{Object Oriented} 
	\item \textbf{Encapsulation} 
	\item \textbf{Platform Independent} 
	\item \textbf{Robust} 
	\item \textbf{Simple} 
	\item \textbf{Secure} 
\end{itemize}

\end{document}
