\documentclass{article}
\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
language=Java,
aboveskip=3mm,
belowskip=3mm,
showstringspaces=false,
columns=flexible,
basicstyle={\small\ttfamily},
numbers=none,
numberstyle=\tiny\color{gray},
keywordstyle=\color{blue},
commentstyle=\color{dkgreen},
stringstyle=\color{mauve},
breaklines=true,
breakatwhitespace=true,
tabsize=3
}
\author{Bob}
\title{Chapter 2 - Operators and Statements}

\begin{document}

\maketitle

\section{Java Operators}
\textbf{Java Operator} : A Java operator is a special symbol that can be applied to a set of variables, values, or literals - referred to as operands - and that returns a result.

\textbf{Types of Java Operators} : There are three flavors of operators available in Java: 
\begin{itemize}
	\item unary
	\item binary
	\item ternary
\end{itemize}

\subsection{Order of Operation}
Unless overridden with parentheses, Java operators follow \emph{order of operation}, listed in this table by decreasing order of \emph{operator precedence}. If two operators have the same level of precedence, then Java guarantees left-to-right evaluation.

\begin{tabular}{|c|c|}
	\cline{1-2}
	Operator & Symbols and examples \\
	\cline{1-2}
	Post-unary operators & expression++, expression-- \\
	Pre-unary operators & ++expression, --expression \\
	Other unary operators & ~,+,-,! \\
	Multiplication/Division/Modulus & *,/,\% \\
	Addition/Subtraction & +,- \\
	Shift operators & <<,>>,>>> \\
	Relational operators & <,>,<=,>=, instanceof \\
	Equal to/not equal to & ==, != \\
	Logical operators & \&,\^,| \\
	Short-circuit logical operators & \&\&,|| \\
	Ternary operators & boolean expression ? expression1 : expression2 \\
	Assignment operators & =,+=,-=,*=,/=,\%=,\&=, \^=, |=, <<=, >>=, >>>= \\
	\cline{1-2}
\end{tabular}


\subsection{Binary Operators}
\subsubsection{Arithmetic Operators}
All of the arithmetic operators may be applied to any Java primitives, except \emph{boolean} and \emph{String}. Furthermore, only the addition operators + and += may be applied to String values, whcih results in String concatenation.

\subsubsection{Numeric Promotion}
\begin{enumerate}
	\item If two values have different data types, Java will automatically promote one of the values to the larger of the two data types.
	\item If one of the values is integral and the other is floating-point, Java will automatically promote the integral value to the floating-point value's data type.
	\item Smaller data types, namely \emph{byte}, \emph{short} and \emph{char}, are first promoted to \emph{int} any time they're used with a Java binary arithmetic operator, even if neither of the operands is \emph{int}.
	\item After all promotion has occurred and the operands have the same data type, the resulting value will have the same data type as its promoted operands.
\end{enumerate}

Note: Unary operators are excluded from this rule.

\subsection{Unary Operators} 
\textbf{Unary Operator} : A unary operator is onen that requires exactly one operand, or variable, to function.

\begin{tabular}{|c|c|}
	\cline{1-2}
	Unary Operator & Description \\
	\cline{1-2}
	+ & Indicates a number is positive, although numbers are assumed to be positive in Java \\
	- & Indicates a literal number is negative or negate an expression \\
	++ & Increments a value by 1 \\
	-- & Decrements a value by 1 \\
	! & Inverts a Boolean's logical value \\
	\cline{1-2}
\end{tabular}

\textbf{Negation Operator (-)} : Reverses the sign of a numeric expression.
\textbf{Logical Complement Operator (!)} : Flips the value of a boolean expression.

Note: Unlike some other programming languages, in Java \emph{1} and \emph{true} are not related in any way, just as \emph{0} and \emph{false} are not related.

\textbf{Increment and Decrement Operators (++, --)} : Increment and decrement operators, ++ and --, respectively, can be appied to numeric operands and have the higher order or precedence, as compared to binary operators. In other words, they often get applied first to an expression.

\subsection{Additional Binary Operators}

\subsubsection{Assignment Operator} 
An \emph{assignment operator} is a binary operator that modifies, or assigns, the variable on the left-hand side of the operator, with the result of the value on the right-hand side of the equation.

Note: \textbf{Java will automatically promote from smaller to larger data types}, but it will throw a compiler exception if it detects you are trying to convert from larger to smaller data types.

\subsubsection{Casting Primitive Values}
Casting primitives is required any time you are going from a larger numerical data type to a smaller numerical data type, or converting from a floating-point number to an integral value.
By performing this \textbf{explicit cast} of a larger value into a smaller dat type, you are instructing the compiler to ignore its default behavior. You are telling the compiler that you have taken additional steps to prevent overflow or underflow.

\textbf{Overflow and Underflow} : \emph{Overflow} is when a number is so large that it will no longer fit within the data type, so the system "wraps around" to the next lowest value and counts up from there. There's also an analogous \emph{underflow}, when the number is too low to fit in the data type.

\subsubsection{Compound Assignment Operators}
Besides the simple assignment operator, =, there are also numerous \emph{compound assignment operators}. 
Complex operators are really just glorified forms of the simple assignment operator, with a built-in arithmetic or logical operation that applies the left- and right-hand sides of the statement and stores the resulting value in a variable in the left-hand side of the statement.
The lef-hand side of the compound operator can only be applied to a variable that is already defined and cannot be used to declare a new variable.

\subsubsection{Relational Operators}
Relational operators compare two expressions and return a \emph{boolean} value. If the two numeric operands are not of the same data type, the smaller one is promoted in the manner as previously discussed.

\begin{tabular}{|c|c|}
	\cline{1-2}
	Operator & Description \\
	\cline{1-2}
	< & Strictly less than \\
	<= & Less than or equal to \\
	> & Strictly greater than \\
	>= & Greater than or equal to \\
	\cline{1-2}
\end{tabular}

\subsubsection{Logical Operators (\&, | and \^)}
The \emph{logical operators}, (\&), (|), and (\^), may be applied to both \emph{numeric} and \emph{boolean} data types, they're referred to as \emph{logical operators}. 
Alternatively, when they're applied to \emph{boolean} data types, they're referred to as \emph{bitwise operators}, as they perform bitwise comparisons of the bits that compose the number.
\subsubsection{Truth Tables}
\textbf{x \& y (AND)}
\begin{tabular}{|c|c|c|}
	\cline{1-3}
	--- & y = true & y = false \\
	\cline{1-3}
	x = true & true & false \\
	\cline{1-3}
	x = false & false & false \\
	\cline{1-3}
\end{tabular}

\textbf{x | y (INCLUSIVE OR)}
\begin{tabular}{|c|c|c|}
	\cline{1-3}
	--- & y = true & y = false \\
	\cline{1-3}
	x = true & true & true \\
	\cline{1-3}
	x = false & true & false \\
	\cline{1-3}
\end{tabular}

\textbf{x \^ y (EXCLUSIVE OR)}
\begin{tabular}{|c|c|c|}
	\cline{1-3}
	--- & y = true & y = false \\
	\cline{1-3}
	x = true & false & true \\
	\cline{1-3}
	x = false & true & false \\
	\cline{1-3}
\end{tabular}
\subsection{Shortcut Operators (\&\& and ||)}
The short-circuit operators are nearly identical to the logical operators, \& and |, respectively, except that \textbf{the right-hand side of the expression may never be evaluated if the final result can be determined by the left-hand side of the expression.}

\subsection{Equality Operators}
Determining equality in Java can be a nontrivial endeavor as ther's a semantic difference between "two objects are the same" and "two objects are equivalent". It is further complicated by the fact that for numeric and boolean primitives, there is no such distinction.

The \emph{equals} operator \emph{==} and \emph{not equals} operator \emph{!=}. Like the relational operators, they compare two operands and return a boolean value about whether the expressions or values are equal, or not equal, respectively.
The equality operators are used in one of three scenarios:
\begin{enumerate}
	\item Comparing two numeric primitive types. If the numeric values are of different data types, the values are automatically promoted.
	\item Comparing two \emph{boolean} values.
	\item Comparing two objects, including \emph{null} and \emph{String} values.
\end{enumerate}

Note: Pay close attention to the data types when you see an equality operator on the exam. (= vs ==)

For object comparison, the equality operator is applied to the references to the objects, not the objects they point to. Two references are equal if and only if they point to the same object, or both point to \emph{null}. (objectA == objectB vs objectA.equals(objectB).
\section{Java Statements}
\textbf{Java Statement} : is a complete unit of execution in Java, terminated with a semicolon (;).

\textbf{Control Flow Statement} : Break up the flow of execution byusing decision making, looping, and branching, allowing the application to selectively execute particular segments of code.

\textbf{Block of Code} : is a group of zero or more statements between balanced braces ({}), and can be used anywhere a single statement is allowed.

\textbf{Decision making control structures}:
\begin{itemize}
	\item if-then
	\item if-then-else
	\item switch
\end{itemize}

\textbf{Repetition control structures}:
\begin{itemize}
	\item for
	\item for-each
	\item while
	\item do-while
\end{itemize}


\subsection{The if-then statement}
The \emph{if-then} statement execute a block of code under certain circumstances, by allowing our application to execute a particular block of code if and only if a \emph{boolean} expression evalueates to true at runtime.

\begin{lstlisting}
if(booleanExpression) {
	// Branch if true
}

\end{lstlisting}

For readability, it is considered good coding practice to put blocks around the execution component of \emph{if-then} statements, as well as many other control flow statements, although it is not required.

Note: In Java tabs are just whitespace and are not evaluated as part of the execution.

\subsection{The if-then-else statemnt}

\begin{lstlisting}
if(booleanExpression) {
	// Branch if true
} else {
	// Branch if false
}
\end{lstlisting}

Note: In Java \emph{0} and \emph{1} are not considered \emph{boolean} values.

\subsubsection{Ternary Operator}
The conditional operator \textbf{? :} otherwise known as \emph{ternary operator}, is the only operator that takes three operands and is of the form:
\begin{lstlisting}
booleanExpression ? expression1 : expression2
\end{lstlisting}
The first operand must be a \emph{boolean} expression, and the second and third can be any expression that returns a value.
The ternary operation is really a condensed form of an \emph{if-then-else} statement that returns a value.
These 2 snippets of code are identical:
With \textbf{if-then-else}:
\begin{lstlisting}
int y = 10;
int x;
if(y > 5) {
	x = 2 * y;
} else {
	x = 3 * y;
}
\end{lstlisting}

With \textbf{Ternary Operator}:
\begin{lstlisting}
int y = 10;
int x = (y > 5) ? (2 * y) : (3 * y);
\end{lstlisting}
Note: add parentheses around the expressions in ternary operations is helpful for readability, although not required.
There is no requirement that second and third expressions in ternary operations have the same data types, although it may come into play when combined with the assignment operator.
\textbf{Ternary Expression Evaluation}: Only one of the right-hand expressions of the ternary operator will be evaluated at runtime. In a manner similar to the short-circuit operators, if one of the two right-hand expressions in a ternary operator performs a side effect, then it may not be applied at runtime.
\begin{lstlisting}
int y = 1;
int z = 1;
final int i = y<10 ? y++ : z++;
System.out.println(y + "," + z); // Outputs 2,1
\end{lstlisting}

\subsection{The switch statement}
A \emph{switch} statement is a complex decision-making structure in which a single value is evaluated and flow is redirected to the first matching branch, known as a \emph{case} statement. If no such case statement is found that matches the value, an optional \emph{default} statement will be called. If no such \emph{default} option is available, the entire switch statement will be skipped.
\subsubsection{Supported Data Types}
A \emph{switch} statement has a target variable that is not evaluated until runtime. Prior to Java 5.0, this variable could only be 
\emph{int} values or those values that could be promoted to \emph{int}, specifically \emph{byte}, \emph{short}, or \emph{int}. In Java 7, \emph{switch} statements were further updated to allow matching on \emph{String} values. Finally, the switch statement also supports any of the primitve numeric wrapper classes, such as \emph{Byte}, \emph{Short}, \emph{Character}, or \emph{Integer}.

\begin{lstlisting}
switch(variableToTest) {
	case constantExpression1:
		// Branch for case1;
		break;

	case constantExpression2:
		// Branch for case2;
		break;

	...

	default:
		// Branch for default;
}
\end{lstlisting}

Data Types supported by \emph{switch} statements include the following:
\begin{itemize}
	\item \emph{byte} and \emph{Byte}
	\item \emph{short} and \emph{Short}
	\item \emph{char} and \emph{Character}
	\item \emph{int} and \emph{Integer}
	\item \emph{String}
	\item \emph{enum} values
\end{itemize}
Note that \emph{boolean} and \emph{long}, and their associated wrapper classes, are not supported by \emph{switch} statements.
\textbf{RULE SWITCH: No boolean, No long}

\subsubsection{Compile-time Constant Values}
The values in each \emph{case} statement must be compile-time constant values of the same data type as the \emph{switch} value. This means that you can use only:
\begin{itemize}
	\item literals
	\item \emph{enum} constants
	\item \emph{final} constant variables of the same data type. By final constant, we mean that the variable must be marked with the \emph{final} modifier and initialized with a literal value in the same expression in which it is declared.
\end{itemize}
\textbf{Break Statement}: There is a \emph{break} statement at the end of each \emph{case} and \emph{default} section. Break statements terminate the \emph{switch} statement and return flow control to the enclosing statement. If you leave out the \emph{break} statement, flow will continue to the next proceeding \emph{case} or \emph{default} block automatically.
Note: There is no requirement that the \emph{case} or \emph{default} statements be in a particular order.
Note: \emph{The exam creators are fond of switch examples that are missing break statements.}
The data type for \emph{case} statements must all match the data type of the \emph{switch} variable.

\textbf{Exit switch}:
\begin{itemize}
	\item break
	\item return
\end{itemize}

\subsection{The while statement}
A repetition control structure, which we refer to as a \emph{loop}, executes a statement of code multiple times in succession.
\begin{lstlisting}
while{booleanExpression) {
	// Body
}
\end{lstlisting}

During execution, the \emph{boolean} expression is evaluated before each iteration of the loop and exits if the evaluation returns false.

\subsection{The do-while statement}
Unlike a \emph{while} loop, though, a \emph{do-while} loop guarantees that the statement or block will be executed at least once.
Note: Any \emph{while} loop can be converted to a \emph{do-while} loop and viceversa.
Java recommends you sue a \emph{while} loop when a loop might not be executed at all an a \emph{do-while} loop when the llop is executed at least once.

\subsection{The for statement}
A basic \emph{for loop} has the same conditional \emph{boolean} expression and statement, or block of statements, as the other loops you have seen, as well as two new sections: an \emph{initialization block} and an \emph{update} statement.

\begin{lstlisting}
for(initialization; booleanExpression; updateStatement) {
	// Body
}
\end{lstlisting}
Note that each section is separated by a semicolon. The initialization and update sections may contain multiple statements, separated by commas.
\textbf{Infinite for loop}:
\begin{lstlisting}
for( ; ; ) {
	// Body
}
\end{lstlisting}
The components of the \emph{for} loop are each optional. The semicolons separating the three sections are required.
The variables in the initialization block must all be of the same type.
\subsection{The for-each statement}
Starting with Java 5.0, Java developers have had a new type of enhanced for loop at their disposal, one specifically designed for iterating over arrays and \emph{Collection} objects.
\begin{lstlisting}
for(datatype instance : collection) {
	// Body
}
\end{lstlisting}

The right-hand side of the \emph{for-each} loop statement must be a built-in Java array or an object whose class implements \emph{java.lang.Iterable}, which includes most of the Java \emph{Collections} framework.
The left-hand side of the \emph{for-each} loop must include a declaration for an instance of a variable, whose type matches the type of a member of the array or collection in the right-hand side of the statement.

\textbf{Collections for OCA Exam}: The only member of the \emph{Collections} framework that you need to be aware of are:
\begin{itemize}
	\item \emph{List}
	\item \emph{ArrayList}
\end{itemize}

Note: When you see a \emph{for-each} loop on the exam, make sure the right-hand side is an array or \emph{Iterable} object and the left-hand side has a matching type.

\textbf{Problem for-each}: While the \emph{for-each} statement is convenient for working with lists in many cases, it does hide access to the loop iterator variable.

As a developer you can always revert to a standard \emph{for} loop if you need fine-grain control.


\end{document}
